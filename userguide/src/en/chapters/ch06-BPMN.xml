<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "../../../target/docbook-tool-1.0/docbook-xml/docbookx.dtd">

<chapter id="bpmn20">
	<title>BPMN</title>

	<section id="whatIsBpmn">

		<title>What is BPMN?</title>

		<para>
		  See our <ulink url="http://activiti.org/faq.html#WhatIsBbpm20">FAQ entry on BPMN 2.0</ulink>
		</para>

	</section>

	<section id="bpmnExamples">

		<title>Examples</title>

		<para>
		  Examples for the BPMN 2.0 constructs described in the following sections can be 
		  found in the <emphasis>docs/examples</emphasis> folder. 
	  </para>
	  
	  <para>	  
		  See the specific section on <link linkend="examples">examples</link> for more information.
		</para>

	</section>

	<section id="bpmnDefiningProcess">

		<title>Defining a process</title>

		<para>
      To create a new BPMN 2.0 process definition, it's best to have your Eclipse
      <link linkend="examples">properly set up</link>.		  
		</para>
		
		<para>
		  Create a new XML file (<emphasis>New->Other->XML-XML</emphasis>) and give it a name.
		  Make sure that the file <emphasis role="bold">ends with .bpmn20.xml</emphasis>, since
		  otherwise the engine won't pick up this file for deployment.
		  <mediaobject><imageobject><imagedata align="center" fileref="images/new.bpmn.procdef.png"/></imageobject></mediaobject>
		</para>
		
		<para>
		  The root element of the BPMN 2.0 schema is the <emphasis role="bold">definitions</emphasis> element.
		  Within this element, multiple process definitions can be defined (altough we advise to have only one
		  process definition in each file, since this simplifies maintenance later in the development process).
		  An empty process definition looks as follows. Note that the minimal definitions element
		  only needs the <emphasis>xmlns</emphasis> and <emphasis>targetNamespace</emphasis> declaration.
		  <programlisting>
&lt;definitions 
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xmlns=&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot;
  xsi:schemaLocation=&quot;http://schema.omg.org/spec/BPMN/2.0 BPMN20.xsd&quot; 
  typeLanguage=&quot;http://www.w3.org/2001/XMLSchema&quot;
  expressionLanguage=&quot;http://www.w3.org/1999/XPath&quot; 
  targetNamespace=&quot;http://www.activiti.org/bpmn2.0&quot;&gt;

  &lt;process id=&quot;myProcess&quot; name=&quot;My First Process&quot;&gt;

  &lt;/process&gt;

&lt;/definitions&gt;</programlisting>
		</para>
		
		<para>
		  Note at the xml namespace that we are using the latest beta version of the 
		  BPMN 2.0 specification, released on 
		  <ulink url="http://www.omgwiki.org/bpmn2.0-ftf/doku.php?id=public:report">May 2010</ulink>.
		</para>
		
		<para>
		  The process element has two attributes:
		  <itemizedlist>
		    <listitem>
		      <para>
		        <emphasis role="bold">id</emphasis>: this attribute is <emphasis role="bold">required</emphasis>
		        and maps to the <emphasis role="bold">key</emphasis> property of an Activiti <emphasis>
		        ProcessDefinition</emphasis> object.
		        This id can then be used to start a new process instance of the process definition, through the 
		        <emphasis>startProcessInstanceByKey</emphasis> method on the <emphasis>ProcessService</emphasis>.
		        This method will always take the <emphasis role="bold">latest deployed version</emphasis>
		        of the process definition.
		        <programlisting>
ProcessInstance processInstance = processService.startProcessInstanceByKey(&quot;<emphasis role="bold">myProcess</emphasis>&quot;);</programlisting>
		        Important to note here is that this is not the same as calling the 
		        <emphasis>startProcessInstanceById</emphasis> method. This method expects the String id 
		        that was generated at deploy time by the Activiti engine, and can be retrieved by calling the
		        <emphasis>processDefinition.getId()</emphasis> method.
		      </para>
		    </listitem>
		    <listitem>
          <para>
            <emphasis role="bold">name</emphasis>: this attribute is <emphasis role="bold">optional</emphasis>
            and maps to the <emphasis>name</emphasis> property of a <emphasis>ProcessDefinition</emphasis>.
            The engine itself doesn't use this property, so it can for example be used for displaying a more
            human-friendly name in a UI.
          </para>
        </listitem>
		  </itemizedlist>
		</para>

	</section>
	
	<section id="10minutetutorial">
	
    <title>Getting started: 10 minute tutorial</title>
    
    <para>
      In this section we will cover a (simple) business process that we will use to introduce
      some basic Activiti concepts and the Activiti API. 
    </para>
    
    <section id="bpmnFirstExampleUseCase">
      
      <title>Use case</title>
      
      <para>
				The use case is very simple: we have a company, let's call it BPMCorp.
				In BPMCorp, a financial report needs to be written every month for the
				company shareholders. This is the responsibility of the accountancy
				department. When the report is finished, one of the members of the
				upper management needs to approve the document before it is sent to all
				the shareholders.
      </para> 
      
      <para>
        All files and code snippets used through the next sections can be found
        in the <link linkend="examples">examples</link> shipped with the Activiti distribution.
        Look for the package <emphasis>org.activiti.examples.bpmn.task</emphasis>.
      </para>   
    
    </section>
    
    <section id="bpmnFirstExampleDiagram">
    
      <title>Process diagram</title>
    
      <para>
				The business process as described above, can be graphically visualized
				using the Activiti Modeler. The end result, in BPMN 2.0 notation, looks
				like this:
			  <mediaobject><imageobject><imagedata align="center" fileref="images/financial.report.example.diagram.png"/></imageobject></mediaobject>
        There is nothing spectaular here. What we see is a <link linkend="bpmnNoneStartEvent">none start event</link> (circle on the left),
        followed by two <link linkend="bpmnUserTask">user tasks</link>:
        <emphasis>'Write monthly financialreport'</emphasis> and 
        <emphasis>'Verify monthly financial report'</emphasis>, ending in
        a <link linkend="bpmnNoneEndEvent">none end event</link> (circle with thick border on the right).
      </para>
    
    </section>
    
    <section id="bpmnFirstExampleXml">
    
      <title>XML representation</title>
      
      <para>
        The XML version of this business process (<emphasis>financial_report_process.bpmn20.xml</emphasis>) looks as shown below.
        It's easy to recognize the main elements of our process (click on the links
        for going to the detailed section of that BPMN 2.0 construct):
        <itemizedlist>
          <listitem>
            <para>
              The <link linkend="bpmnNoneStartEvent">(none) start event</link>
              learns us where to start with the process
            </para>
          </listitem>
          <listitem>
            <para>
              The <link linkend="bpmnUserTask">user tasks</link> declarations are the representation
              of the human tasks of our process. Note that the first task is assigned
              to the <emphasis>accountancy</emphasis> group, while the second task is 
              assigned to the <emphasis>management</emphasis> group.
              See <link linkend="bpmnUserTaskAssignment">the section on user task assignment</link>
              for more information on how users and groups can be assigned
              to user tasks.
            </para>
          </listitem>
          <listitem>
            <para>
              The process ends when the <link linkend="bpmnNoneEndEvent">none end event</link>
              is reached.
            </para> 
          </listitem>
        </itemizedlist>
        <programlisting>
&lt;process id=&quot;financialReport&quot; name=&quot;Monthly financial report reminder process&quot;&gt;
  
  &lt;startEvent id=&quot;theStart&quot; /&gt;
    
  &lt;sequenceFlow id='flow1' sourceRef='theStart' targetRef='writeReportTask' /&gt;
    
  &lt;userTask id=&quot;writeReportTask&quot; name=&quot;Write monthly financial report&quot; &gt;
    &lt;documentation&gt;
      Write monthly financial report for publication to shareholders.
    &lt;/documentation&gt;
    &lt;potentialOwner&gt;
      &lt;resourceAssignmentExpression&gt;
        &lt;formalExpression&gt;accountancy&lt;/formalExpression&gt;
      &lt;/resourceAssignmentExpression&gt;
    &lt;/potentialOwner&gt;
  &lt;/userTask&gt;
    
  &lt;sequenceFlow id='flow2' sourceRef='writeReportTask' targetRef='verifyReportTask' /&gt;
      
  &lt;userTask id=&quot;verifyReportTask&quot; name=&quot;Verify monthly financial report&quot; &gt;
    &lt;documentation&gt;
      Verify monthly financial report composed by the accountancy departement.
      This financial report is going to be sent to all the company shareholders.  
    &lt;/documentation&gt;
    &lt;potentialOwner&gt;
      &lt;resourceAssignmentExpression&gt;
        &lt;formalExpression&gt;management&lt;/formalExpression&gt;
      &lt;/resourceAssignmentExpression&gt;
    &lt;/potentialOwner&gt;
  &lt;/userTask&gt;
    
  &lt;sequenceFlow id='flow3' sourceRef='verifyReportTask' targetRef='theEnd' /&gt;
      
  &lt;endEvent id=&quot;theEnd&quot; /&gt;
      
&lt;/process&gt;</programlisting>        
      </para>
    
    </section>
    
    <section id="bpmnFirstExamplStartProcess">
    
      <title>Starting a process instance</title>
      
      <para>
        We now have defined the <emphasis role="bold">process definition</emphasis> of our
        business process. From such a process
        definition, we can create at runtime <emphasis role="bold">process instances</emphasis>.
        In this case, one process instance would match with the creation and verification
        of the financial report every month.
      </para>
      
      <para>
        To be able to create process instances from a given process definition,
        we must first <emphasis role="bold">deploy</emphasis> this process definition.
        Deploying a process definition means two things:
        <itemizedlist>
          <listitem>
            <para>
              The process definition will be stored in the persistent datastore that
              is configured for your Activiti engine. So by deploying our business process,
              we make sure that the engine will find the process definition after an engine reboot.
            </para>
          </listitem>
          <listitem>
            <para>
              The BPMN 2.0 process file will be parsed to an in-memory object model
              that can be manipulated through the Activiti API.
            </para>
          </listitem>
        </itemizedlist>
        More informaton on deployment can be found <link linkend="chDeployment">in the dedicated deployment section</link>.
      </para>
      
      <para>
        As described <link linkend="chDeployment">in that section</link>, deployment can happen in several
        ways. One way is through the API as follows:
        <programlisting>
Deployment deployment = processService.newDeployment()
  .addClasspathResource(&quot;org/activiti/examples/bpmn/task/financial_report_process.bpmn20.xml&quot;)
  .deploy();</programlisting>
      </para>
      
      <para>
        Now we can start a new process instance using 
        the <emphasis>id</emphasis> we defined in the process definition (see first line of the XML).
        Note that this <emphasis>id</emphasis> in Activiti terminology
        is called the <emphasis role="bold">key</emphasis>.
        <programlisting>ProcessInstance processInstance = processService.startProcessInstanceByKey(&quot;financialReport&quot;);</programlisting>
        This will create a runtime execution that
        will go first through the start event. After the start event, it follows all the outgoing
        sequence flow (only one in this case) and the first task ('write monthly financial report')
        is reached. The Activiti engine will now store a task in the persistent datastore. 
        At this point, the user or group assignments attached to the task are resolved and also stored in the 
        datastore.
      </para>
      
      <para>
        After the task is created, the <emphasis>startProcessInstanceByKey</emphasis> will return
        since the user task activity is a so-called <emphasis>'wait state'</emphasis>, which
        means that the engine will continue the process instance only when some external trigger is 
        given. In this case, the task is assigned to a group, which means that the every
        member of the group is a <emphasis role="bold">candidate</emphasis> to perform the task.
      </para>
    
    </section>
    
    <section id="bpmnFirstExampleCandidateList">
    
      <title>Task lists</title>  
      
      <para>
        We can now retrieve this newly created task through the <emphasis>taskService</emphasis>.
        <programlisting>List&lt;Task&gt; tasks = taskService.findUnassignedTasks(&quot;fozzie&quot;);</programlisting>.
        Note that the user we pass to this operation needs to be a member of 
        the <emphasis>accountancy</emphasis> group, since that was declared in the process definition:
        <programlisting>
&lt;potentialOwner&gt;
  &lt;resourceAssignmentExpression&gt;
    &lt;formalExpression&gt;<emphasis role="bold">accountancy</emphasis>&lt;/formalExpression&gt;
  &lt;/resourceAssignmentExpression&gt;
&lt;/potentialOwner&gt;</programlisting>
     
        We could also use the task query API to get the same results:
        <programlisting>List&lt;Task&gt; tasks = taskService.createTaskQuery().candidateUser(&quot;fozzie&quot;).list();</programlisting>
        or
         <programlisting>List&lt;Task&gt; tasks = taskService.createTaskQuery().candidateGroup(&quot;accountancy&quot;).list();</programlisting>
      </para>
      
      <para>
        The business process described here is also deployed as an example to the demo setup database.
        After running the <link linkend="demo.setup">demo setup</link>, log into the Activiti Explorer
        as <emphasis role="bold">fozzie</emphasis> (he's an accountant),
        and select in the drop down menu on the right the <emphasis>'Monthly financial report'</emphasis> process.
        
        <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.financial.report.example.start.process.png"/></imageobject></mediaobject>
        
        As explained, the process will execute up to the first user task. Since we're logged in
        as fozzie, we can see that there is a new candidate task available for him after we've started
        the process instance.
        Note that even if the process was started by someone else, the task would still
        be visible as a candidate task to everyone in the accountancy group.
        
        <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.financial.report.example.task.assigned.png"/></imageobject></mediaobject>
        
      </para>
      
    </section>
    
    <section id="bpmnFirstExampleClaimTask">
    
      <title>Claiming the task</title>
      
      <para>
        An accountant now needs to <emphasis role="bold">claim the task</emphasis>. By claiming the
        task, the specific user will become the <emphasis role="bold">assignee</emphasis> of the task
        and the task will dissapear from every task list of the other members of the accountancy group.
        Claiming a task is programmatically done as follows:
        <programlisting>taskService.claim(task.getId(), &quot;fozzie&quot;);</programlisting>
        The task is now in the <emphasis role="bold">personal task list of the one
        that claimed the task</emphasis>.
        <programlisting>List&lt;Task&gt; tasks = taskService.findAssignedTasks(&quot;fozzie&quot;);</programlisting>
      </para>
      
      <para>
        In the Activiti Explorer UI, clicking the <emphasis>claim</emphasis> button will
        call the same operation. The task will now move to the personal task list of the logged
        on user.
        
       <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.financial.report.example.claim.task.png"/></imageobject></mediaobject>
      </para>
      
    </section>
      
    <section id="bpmnFirstExampleCompleteTask">
    
      <title>Completing the task</title>
      
      <para>
        The accountant can now start working on the financial report. Once the report is finished,
        he can <emphasis role="bold">complete the task</emphasis>, which means that all
        work for that task is done.
        <programlisting>taskService.complete(task.getId());</programlisting>
      </para>
      
      <para>
        For the Activiti engine, this is an external signal that the process instance execution
        must be continued. The single outgoing transition out of the task is followed, bringing
        the execution in the second task (<emphasis>'verifcation of the report'</emphasis>). 
        The same mechanism as described for the first task will now
        happen, with the small difference that the task will be assigned to the 
        <emphasis>management</emphasis> group.
      </para>
      
      <para>
        In the demo setup, completing the task is done by clicking the <emphasis>complete</emphasis>
        button in the task list. Since Fozzie isn't an accountant, we need to log out of
        the Activiti Explorer and login in as <emphasis>kermit</emphasis> (which is a manager).
        The second task is now visible in the unassigned task lists.
        
        <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.financial.report.example.complete.task.png"/></imageobject></mediaobject>
      </para>
      
    </section>
      
    <section id="bpmnFirstExampleEndingProcess">

      <title>Ending the process</title>
        
      <para>
        The verification task can be retrieved and claimed in exactly the same way as before.
        Completing this second task, will bring process execution at the end event, which finishes
        the process instance. The process instance and all related runtime execution data
        is removed from the datastore.
      </para>
      
      <para>
        When you log into Activiti Probe you can verify this, since no records will be 
        found in the table where the process executions are stored.
        
         <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.financial.report.example.process.ended.png"/></imageobject></mediaobject> 
      </para>
      
    </section>
    
    <section id="bpmnFirstExampleFutureEnhancements">
    
      <title>Future enhancements</title>
      
      <para>
        It's easy to see that this business process is too simple to be useable in reality.
        However, as you are going through the BPMN 2.0 constructs available in Activiti, 
        you will be able to enhance the business process by 
        
        <itemizedlist>
          <listitem>
            <para>
              defining a <emphasis role="bold">timer start event</emphasis> that
              automatically starts a process instance at the end of every month.
            </para>
          </listitem>
          <listitem>
            <para>
              defining <emphasis role="bold">gateways</emphasis> that act as decisions.
              This way, a manager could reject the financial report which would recreate
              the task for the accountant. 
            </para>
          </listitem>
          <listitem>
            <para>
              declaring and using <emphasis role="bold">variables</emphasis>,
              such that we can store or reference the report such that it can 
              be visualized while verifying it.
            </para>
          </listitem>
          <listitem>
            <para>
              defining a <emphasis role="bold">service task</emphasis> at the end of
              the process that will send the report to every shareholder.
            </para>
          </listitem>
          <listitem>
            <para>
              etc.
            </para>
          </listitem>
        </itemizedlist>
      </para>
    
    </section>
  	
	</section>

	<section id="bpmnConstructs">

		<title>BPMN 2.0 constructs</title>
		
			<section id="bpmnCustomExtensions">
	
	    <title>Custom extensions</title>
	
	    <para>
	      The BPMN 2.0 standard is a good thing for all parties involved. End-users don't suffer
	      from a vendor lock-in that comes by depending on a proprietary solution. Frameworks,
	      and particularly open-source frameworks such as Activiti, can implement a solution
	      that has the same (and often better implemented) features as those of a big vendor. 
	      Due to the BPMN 2.0 standard, the transition from such a big vendor solution towards
	      Activiti is an easy and smooth path.  
	    </para>
	    
	    <para>
	      The downside of a standard however, is the fact that it is always the result of 
	      many discussions and compromises between different companies (and often visions). 
	      As a developer reading the BPMN 2.0 XML of a process definition, sometimes it feels like 
	      certain constructs or way to do things are too cumbersome.
	      Since Activiti puts ease of development as a top-priority, we introduced something called the
	      <emphasis role="bold">'Activiti BPMN extensions'</emphasis>.
	      These 'extensions' are new constructs or ways to simplify certain constructs, that
	      are not in the BPMN 2.0 specification.
	    </para>
	    
	    <para>
	      Altough the BPMN 2.0 specification clearly states that it was made for custom extension,
	      we make sure that:
	      <itemizedlist>
	        <listitem>
	          <para>
	            The prerequisite of such a custom extension is that there 
	            <emphasis role="bold">always</emphasis> must be a simple tranformation to
	            the <emphasis role="bold">standard way of doing things</emphasis>.
	            So when you decide to use a custom extension, you don't have to be afraid 
	            that there is no way back.
	          </para>
	        </listitem>
	        <listitem>
	          <para>
	            When using a custom extension, this is always clearly indicated by giving
	            the new XML element, attribute, etc. the <emphasis role="bold">activiti:</emphasis> 
	            namespace prefix.
	          </para>
	        </listitem>
	        <listitem>
	          <para>
	            The goal of these extensions is to eventually push them back into a next version
	            of the BPMN specification, or at least trigger a discussion that can lead to a revision
	            of that specific BPMN construct. 
	          </para>
	        </listitem>
	      </itemizedlist> 
	    </para>
	    
	    <para>
	      So whether you want to use a custom extension or not, is completely up to you. 
	      Several factors will influence this decision (graphical editor usage, company policy, etc.).
	      We only provide them since we believe that some points in the standard can be done
	      simpler or more efficient. Feel free to give us (positive and/or negative) feedback on 
	      our extensions, or to post new ideas for custom extensions. Who knows, some day your idea
	      might pop up in the specification!.
	    </para>
	  
	  </section>
	  
	  <section id="bpmnEvents">
	   
	    <title>Events</title>
	    
	    <para>
	     Events are used to model something that happens during the lifetime process.
	     Events are always visualized as a circle.
	     
	     In BPMN 2.0, there exist
	     two main event categories: <emphasis>catching</emphasis> or <emphasis>throwing</emphasis> event.
       <itemizedlist>
         <listitem>
           <para>
             <emphasis role="bold">Catching: </emphasis>when process execution arrives in the event,
             it will wait for a trigger to happen. The type of trigger is defined by the inner icon
             or the type declaration in the XML. Catching events are visually differentiated from a 
             throwing event by the inner icon that is not filled (ie. it is white).
           </para>
         </listitem>
         <listitem>
           <para>
             <emphasis role="bold">Throwing: </emphasis>when process execution arrives in the event, a 
              trigger is fired. The type of trigger is defined by the inner icon or the type declaration
              in the XML. Throwing events are visually differentiated from a catching event by
              the inner icon that is filled with black.
           </para>
         </listitem>
       </itemizedlist>
	     
	    </para>
	   
	  </section>
	  
	  <section id="bpmnStartEvents">
	  
	   <title>Start events</title>
	  
	   <para>
	     A start event indicates where a process starts. The type of start event (process starts on receival of 
	     message, on specific time intervals, etc.), defining <emphasis>how</emphasis> the process is
	     started is shown as a small icon in the visual representation of the event. In the XML representation,
	     the type is given by the declaration of a subelement.
	   </para>
	   
	   <para>
	     Start events <emphasis role="bold">are always catching</emphasis>: conceptually
	     the event is (at any time) waiting until a certain trigger happens.
	   </para>
	  
	  </section>

		<section id="bpmnNoneStartEvent">

			<title>None start event</title>
			
			<section id="noneStartEventDescription">
       
        <title>Description</title>
        
        <para>
          A 'none' start event technically means that the trigger for starting the process instance
          is unspecified. This means that the engine cannot anticipate when the process instance must
          be started. The none start event is used when the process instance is started through the API
          by calling one of the <emphasis>startProcessInstanceByXXX</emphasis> methods.
          <programlisting>
ProcessInstance processInstance = processService.startProcessInstanceByXXX();</programlisting>
        </para>
        
        <para>
          <emphasis>Note: </emphasis> a subprocess (currently not yet implemented)
          always has a none start event.
        </para>
       
      </section>

			<section id="noneStartEventGraphicalNotation">
			 
			  <title>Graphical notation</title>
			  
			  <para>
			    A none start event is visualized as a circle with no inner icon (ie. no trigger type). 
			    <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.none.start.event.png"/></imageobject></mediaobject>
			  </para>
			 
			</section>
			
			<section id="noneStartEventXml">
       
        <title>XML representation</title>
        
        <para>
          The XML representation of a none start event is the normal
          start event declaration, without any subElement (other start event types
          all have a subElement declaring the type).
          <programlisting>
&lt;startEvent id=&quot;start&quot; name=&quot;my start event&quot; /&gt;</programlisting>
        </para>
       
      </section>

		</section>
		
		<section id="bpmnEndEvent">
		
		  <title>End events</title>
		  
		  <para>
		    An end event signifies the end (of a path) of a (sub)process. An end event is 
		    <emphasis role="bold">always throwing</emphasis>. This means that when process execution
		    arrives in the end event, a <emphasis>result</emphasis> is thrown. The type of result 
		    is depicted by the inner black icon of the event. In the XML representation,
		    the type is given by the declaration of a subelement.
		  </para>
		
		</section>

		<section id="bpmnNoneEndEvent">
		
		  <title>None end event</title>

      <section id="noneEndEventDescription">

			 <title>Description</title>
        
        <para>
          A 'none' end event means that the <emphasis>result</emphasis> thrown when
          the event is reached is unspecified. As such, the engine will not do anything
          extra besides ending the current path of execution.
        </para>
       
      </section>

      <section id="bpmnNoneEndEventDescription">
       
        <title>Graphical notation</title>
        
        <para>
          A none end event is visualized as a circle with a thick border with no inner icon (no result type).
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.none.end.event.png"/></imageobject></mediaobject>
        </para>
       
      </section>
      
      <section id="bpmnNoneStartEventXml">
       
        <title>XML representation</title>
        
        <para>
          The XML representation of a none end event is the normal
          end event declaration, without any subElement (other end event types
          all have a subElement declaring the type).
          <programlisting>
&lt;endEvent id=&quot;end&quot; name=&quot;my end event&quot; /&gt;</programlisting>
        </para>
       
      </section>

		</section>
		
	  <section id="bpmnSequenceFlow">
    
      <title>Sequence flow</title>
      
      <section id="sequenceFlowDescription">
      
        <title>Description</title>
        
        <para>
          A sequence flow is the connector between two elements of a process.
          After an element is visited during process execution, all outgoing sequence flow
          will be followed. This means that the default nature of BPMN 2.0 is to be parallel:
          two outgoing sequence flow will create two separate, parallel paths of execution.
        </para>
      
      </section>
      
      <section id="sequenceFlowGraphicalNotation">
      
        <title>Graphical notation</title>
        
        <para>
          A sequence flow is visualized as an arrow going from the source element towards
          the target element. The arrow always points towards the target.
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.sequence.flow.png"/></imageobject></mediaobject>
        </para>
      
      </section>
      
      <section id="sequenceFlowXml">
      
        <title>XML representation</title>
        
        <para>
          Sequence flow need to have a process-unique <emphasis role="bold">id</emphasis>,
          and a reference to an existing <emphasis role="bold">source</emphasis>
          and <emphasis role="bold">target</emphasis> element.
          <programlisting>
&lt;sequenceFlow id=&quot;flow1&quot; sourceRef=&quot;theStart&quot; targetRef=&quot;theTask&quot; /&gt;</programlisting>
        </para>
      
      </section>
    
    </section>
    
    <section id="bpmnConditionalSequenceFlow">
    
      <title>Conditional sequence flow</title>
      
      <section id="condSeqFlowDescription">
      
        <title>Description</title>
        
        <para>
          A sequence flow can have a condition defined on it. When a BPMN 2.0 activity
          is left, the default behaviour is to evaluate the conditions on the outgoing
          sequence flow. When a condition evaluates to <emphasis>true</emphasis>, that
          outgoing sequence flow is selected. When multiple sequence flow are selected
          that way, multiple <emphasis>executions</emphasis> will be generated
          and the process will be continued in a parallel way.
        </para>
        
        <para>
          <emphasis role="bold">Note:</emphasis> the above holds for BPMN 2.0 activities (and events),
          but not for gateways. Gateways will handle sequence flow with conditions in specific ways,
          depending on the gateway type.
        </para>
      
      </section>
      
      <section id="conditionalSequenceFlowGraphicalNotation">
      
        <title>Graphical notation</title>
        
        <para>
          A conditional sequence flow is visualized as a regular sequence flow,
          with a small diamond at the beginning. The condition expression is shown
          next to the sequence flow.
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.conditional.sequence.flow.png"/></imageobject></mediaobject>
        </para>
      
      </section>
      
      <section id="sequenceFlowXml">
      
        <title>XML representation</title>
        
        <para>
          A conditional sequence flow is represented in XML as a regular sequence flow,
          containing a <emphasis role="bold">conditionExpression</emphasis> sub-element.
          Note that for the moment only <emphasis>tFormalExpressions</emphasis> are supported,
          Omitting the <emphasis>xsi:type=&quot;&quot;</emphasis> definition will simply
          default to this only supported type of expressions. 
          <programlisting>&lt;sequenceFlow id=&quot;flow&quot; sourceRef=&quot;theStart&quot; targetRef=&quot;theTask&quot;&gt;
  &lt;conditionExpression xsi:type=&quot;tFormalExpression&quot;&gt;
    &lt;![CDATA[${order.price &gt; 100 &amp;&amp; order.price &lt; 250}]]&gt;
  &lt;/conditionExpression&gt;
&lt;/sequenceFlow&gt;</programlisting>
        </para>
        
        <para>
          Activiti supports two kind of expressions: UEL-value and UEL-method expressions 
          (UEL stands for <emphasis>Unified Expression Language</emphasis> and is part of the EE6 specification, see
          <ulink url="http://docs.sun.com/app/docs/doc/820-7627/gjddd?l=en&amp;a=view">
          the EE6 specification</ulink> for detailed information)
        </para>
        
        <para>
          Specifying the type of expression, is done through the <emphasis role="bold">language</emphasis>
          attribute on the <emphasis>expression</emphasis> element:
  <programlisting>
&lt;conditionExpression xsi:type=&quot;tFormalExpression&quot; <emphasis role="bold">language=&quot;uel-value | uel-method</emphasis>&quot;>
  &lt;![CDATA[${order.isStandard}]]&gt;
&lt;/conditionExpression&gt;</programlisting>
        </para>
        
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <emphasis role="bold">uel-value</emphasis>: references data of a process 
                variable, in the typical JavaBean style through getters. 
              </para>
              <para>
<programlisting>&lt;conditionExpression xsi:type=&quot;tFormalExpression&quot; <emphasis role="bold">language=&quot;uel-value&quot;</emphasis>&gt;
  &lt;![CDATA[${order.price &gt; 100 &amp;&amp; order.price &lt; 250}]]&gt;
&lt;/conditionExpression&gt;</programlisting>
              </para>
            </listitem>
             <listitem>
              <para>
                <emphasis role="bold">uel-method</emphasis>: invokes a method that resolves to a boolean value.
<programlisting>&lt;conditionExpression xsi:type=&quot;tFormalExpression&quot; <emphasis role="bold">language=&quot;uel-method&quot;</emphasis>&gt;
  &lt;![CDATA[${order.isStandardOrder}]]&gt;
&lt;/conditionExpression&gt;</programlisting>                
              </para>
            </listitem>
          </itemizedlist>
          Note that these expressions support resolving primitives (incl. comparing them), beans, lists, arrays and maps.
          <emphasis role="bold">If no value for the language attribute is specified, by default
          the expression is resolved as a value expression.</emphasis> 
        </para>
        
        <para>
          The Activiti distribution contains the following example process using value and method expressions
          (see <emphasis>org.activiti.examples.bpmn.expression)</emphasis>:
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.uel-expression.on.seq.flow.png"/></imageobject></mediaobject>
        </para>
      
      </section>
      
    </section>
    
    <section id="bpmnGateways">
    
      <title>Gateways</title>
      
      <para>
        A gateway is used to control the flow of execution (or as the BPMN 2.0 describes,
        the <emphasis>tokens</emphasis> of execution). A gateway is capable of <emphasis>consuming</emphasis>
        or <emphasis>generating</emphasis> tokens.
      </para>
        
      <para>  
        A gateway is graphically visualized as a diamond shape, with an icon inside. 
        The icon shows the type of gateway.
         <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.gateway.png"/></imageobject></mediaobject>
      </para>
    
    </section>
    
    <section id="bpmnExclusiveGateway">
    
      <title>Exclusive gateway</title>
      
      <section id="exclusiveGatewayDescription">
      
        <title>Description</title>
        
        <para>
          An exclusive gateway (also called the <emphasis>XOR gateway</emphasis> 
          or more technical the <emphasis>exclusive data-based gateway</emphasis>),
          is used to model a <emphasis role="bold">decision</emphasis> in the proces.
          When the execution arrives at this gateway, all outgoing sequence flow are
          evaluated in the order in which they are defined. The sequence flow
          which condition evaluates to true (or which doesn't have a condition set, 
          conceptually having a <emphasis>'true'</emphasis> defined on the sequence flow)
          is selected for continuing the process. 
        </para>
        
        <para>
          <emphasis role="bold">Note that the semantics of outgoing sequence flow is 
          different to that of the general case in BPMN 2.0. While in general all sequence
          flow which condition evaluates to true are selected to continue in a parallel way,
          only one sequence flow is selected when using the exclusive gateway. 
          In case multiple sequence flow have a condition that evaluates to true, the 
          first one defined in the XML (and only that one!) is selected for continuing the process.
          If no sequence flow can be selected, an exception will be thrown.</emphasis>
        </para>
        
      </section>
      
      <section id="exclusiveGatewayGraphNotation">
      
        <title>Graphical notation</title>
        
        <para>
          An exclusive gateway is visualized as a typical gateway (ie. a diamond shape)
          with an 'X' icon inside, referring to the <emphasis>XOR</emphasis> semantics.
          Note that a gateway without an icon inside defaults to an exclusive gateway.
          The BPMN 2.0 specification does not allow mixing the diamond with and without an X
          in the same process definition.
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.exclusive.gateway.notation.png"/></imageobject></mediaobject>
        </para>
      
      </section>
      
      <section id="exclusiveGatewayXML">
      
        <title>XML representation</title>
        
        <para>
          The XML representation of an exclusive gateway is straight-forward: one line defining
          the gateway and condition expressions defined on the outgoing sequence flow. 
          See the section on <link linkend="bpmnConditionalSequenceFlow">conditional sequence flow</link>
          to see which options are available for such expressions.
       </para>
       
       <para>   
          Take for example the following model:
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.exclusive.gateway.png"/></imageobject></mediaobject> 
          Which is represented in XML as follows:
          <programlisting>&lt;exclusiveGateway id=&quot;exclusiveGw&quot; name=&quot;Exclusive Gateway&quot; /&gt;
    
&lt;sequenceFlow id=&quot;flow2&quot; sourceRef=&quot;exclusiveGw&quot; targetRef=&quot;theTask1&quot;&gt;
  &lt;conditionExpression xsi:type=&quot;tFormalExpression&quot;&gt;${input == 1}&lt;/conditionExpression&gt;
&lt;/sequenceFlow&gt;
    
&lt;sequenceFlow id=&quot;flow3&quot; sourceRef=&quot;exclusiveGw&quot; targetRef=&quot;theTask2&quot;&gt;
  &lt;conditionExpression xsi:type=&quot;tFormalExpression&quot;&gt;${input == 2}&lt;/conditionExpression&gt;
&lt;/sequenceFlow&gt;
    
&lt;sequenceFlow id=&quot;flow4&quot; sourceRef=&quot;exclusiveGw&quot; targetRef=&quot;theTask3&quot;&gt;
  &lt;conditionExpression xsi:type=&quot;tFormalExpression&quot;&gt;${input == 3}&lt;/conditionExpression&gt;
&lt;/sequenceFlow&gt;</programlisting>
        </para>
        
      </section>
    
    </section>
    
    <section id="bpmnParallelGateway">
      
      <title>Parallel Gateway</title>
      
      <section id="bpmnParallelGatewayDescription">
        
        <title>Description</title>
        
        <para>
          Gateways can also be used to model concurrency in a process. The most straightforward
          gateway to introduce concurrency in a process model, is the 
          <emphasis role="bold">Parallel Gateway</emphasis>, which allows to <emphasis>fork</emphasis> 
          into multiple paths of execution or <emphasis>join</emphasis> multiple incoming paths
          of execution.
        </para>
        
        <para>
          The funtionality of the parallel gateway is based on the incoming and outgoing sequence flow:
          <itemizedlist>
            <listitem>
              <para>
                <emphasis role="bold">join:</emphasis>   
                all concurrent executions arriving at the parallel gateway wait in the gateway
                until an execution has arrived for each of the incoming sequence flow. Then the 
                process continues past the joining gateway.
              </para>
            </listitem>
            <listitem>
              <para>
                <emphasis role="bold">fork:</emphasis>
                all outgoing sequence flow are followed in parallel, creating one concurrent
                execution for each sequence flow.
              </para>
            </listitem>
          </itemizedlist>
          Note that a parallel gateway can have <emphasis role="bold">both fork and join behavior</emphasis>,
          if there are multiple incoming and outgoing sequence flow for the same parallel gateway.
          In that case, the gateway will first join all incoming sequence flow, before splitting
          into multiple concurrent paths of executions.
        </para>
        
        <para>
          <emphasis role="bold">An important difference with other gateway types is that
          the parallel gateway does not evaluate conditions. If conditions are defined
          on the sequence flow connected with the parallel gateway, they are simply neglected.</emphasis>  
        </para>
      
      </section>
      
      <section id="bpmnParallelGatewayGraphicalNotation">
        
        <title>Graphical Notation</title>
        
        <para>
          A parallel gateway is visualized as a gateway (diamond shape) with the 'plus' symbol inside,
          referring to the 'AND' semantics.
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.parallel.gateway.png"/></imageobject></mediaobject>
        </para>
      
      </section>
      
      <section id="bpmnParallelGatewayyXML">
        
        <title>XML representation</title>
        
        <para>
          Defining a parallel gateway needs one line of XML:
          <programlisting>&lt;parallelGateway id=&quot;myParallelGateway&quot; /></programlisting>
          The actual behavior (fork, join or both), is defined by 
          the sequence flow connected to the parallel gateway.
        </para>
      
        <para>
          For example, the model above comes down to the following XML:
<programlisting>
    &lt;startEvent id=&quot;theStart&quot; /&gt;
    &lt;sequenceFlow id=&quot;flow1&quot; sourceRef=&quot;theStart&quot; targetRef=&quot;fork&quot; /&gt;
    
    <emphasis role="bold">&lt;parallelGateway id=&quot;fork&quot; /&gt;</emphasis>
    &lt;sequenceFlow sourceRef=&quot;fork&quot; targetRef=&quot;receivePayment&quot; /&gt;
    &lt;sequenceFlow sourceRef=&quot;fork&quot; targetRef=&quot;shipOrder&quot; /&gt;
    
    &lt;userTask id=&quot;receivePayment&quot; name=&quot;Receive Payment&quot; /&gt;  
    &lt;sequenceFlow sourceRef=&quot;receivePayment&quot; targetRef=&quot;join&quot; /&gt;
    
    &lt;userTask id=&quot;shipOrder&quot; name=&quot;Ship Order&quot; /&gt; 
    &lt;sequenceFlow sourceRef=&quot;shipOrder&quot; targetRef=&quot;join&quot; /&gt;
    
    <emphasis role="bold">&lt;parallelGateway id=&quot;join&quot; /&gt;</emphasis>
    &lt;sequenceFlow sourceRef=&quot;join&quot; targetRef=&quot;archiveOrder&quot; /&gt;
    
    &lt;userTask id=&quot;archiveOrder&quot; name=&quot;Archive Order&quot; /&gt; 
    &lt;sequenceFlow sourceRef=&quot;archiveOrder&quot; targetRef=&quot;theEnd&quot; /&gt;
    
    &lt;endEvent id=&quot;theEnd&quot; /&gt;
</programlisting>
        </para>
        
        <para>
          In the above example, after the process is started, two tasks will be created:
          <programlisting>
  ProcessInstance pi = processService.startProcessInstanceByKey(&quot;forkJoin&quot;);
  TaskQuery query = deployer.getTaskService()
                           .createTaskQuery()
                           .processInstance(pi.getId())
                           .orderAsc(TaskQuery.PROPERTY_NAME);

  List&lt;Task&gt; tasks = query.list();
  assertEquals(2, tasks.size());
  
  Task task1 = tasks.get(0);
  assertEquals(&quot;Receive Payment&quot;, task1.getName());
  Task task2 = tasks.get(1);
  assertEquals(&quot;Ship Order&quot;, task2.getName());
          </programlisting>
          When these two tasks are completed, the second parallel gateway will join the two
          executions and since there is only one outgoing sequence flow, no concurrent paths
          of execution will be created, and only the <emphasis>Archive Order</emphasis>
          task will be active.
        </para>
        
        <para>
          Note that a parallel gateway does not need to be 'balanced' (ie. a matching number
          of incoming/outgoing sequence flow for corresponding parallel gateways). 
          A parallel gateway will simply wait for all incoming sequence flow and create 
          a concurrent path of execution for each outgoing sequence flow, not influenced by
          other constructs in the process model. So, the following process is legal in BPMN 2.0:
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.unbalanced.parallel.gateway.png"/></imageobject></mediaobject>
        </para>
      
      </section>
   
    </section> 

		<section id="bpmnUserTask">

			<title>User task</title>

			<section id="bpmnUserTaskDescription">
			
			 <title>Description</title>
			 
			 <para>
			   A 'user task' is used to model work that needs to be done by a human actor. 
			   When process executes arrives at such a user task, a new task is created in the 
			   task list of the user(s) or group(s) assigned to that task.
			 </para>
			
			</section>
			
			<section id="bpmnUserTaskGraphicalNotation">
			
			 <title>Graphical notation</title>
			 
			 <para>
			   A user task is visualized as a typical task (rounded rectangle), with a small
			   user icon in the left upper corner.
			   <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.user.task.png"/></imageobject></mediaobject>
			 </para>
			
			</section>
			
			<section id="bpmnUserTaskXml">
			
				<title>XML representation</title>
				
				<para>
				  A user task is defined in XML as follows. The <emphasis>id</emphasis> attribute
				  is required, the <emphasis>name</emphasis> attribute is optional.
				  <programlisting>
&lt;userTask id=&quot;theTask&quot; name=&quot;Important task&quot; /&gt;			  
				  </programlisting>
				</para>
				
				<para>
			    A user task can have also a description. In fact any BPMN 2.0 element can have
				  a description, but for the moment we've only implemented it for user tasks
				  since it makes most sense there. A description is defined by adding
				  the <emphasis role="bold">documentation</emphasis> element. Note that only one
				  <emphasis>documentation</emphasis> element is supported at the moment
				  (can be multiple according to the specification).
				  <programlisting>
&lt;userTask id=&quot;theTask&quot; name=&quot;Schedule meeting&quot; &gt;
  &lt;documentation&gt;
	  Schedule an engineering meeting for next week with the new hire.
	&lt;/documentation&gt;</programlisting>
				
				  The description text can be retrieved from the task in the standard Java way:
				  <programlisting>task.getDescription()</programlisting>
				</para>
			
			</section>

			<section id="bpmnUserTaskAssignment">

				<title>User assignment</title>

				<para>
				  A user task can be directly assigned to a user. This is done by defining a
				  <emphasis role="bold">humanPerformer</emphasis> sub element.
				  Such a <emphasis>humanPerformer</emphasis> definition needs a 
				  <emphasis role="bold">resourceAssignmentExpression</emphasis> that actually defines
				  the user. Currently, only <emphasis role="bold">formalExpressions</emphasis> are supported.
				  <programlisting>
&lt;process ...
  
  ...
  
  &lt;userTask id='theTask' name='important task' &gt;
    &lt;humanPerformer&gt;
      &lt;resourceAssignmentExpression&gt;
        &lt;formalExpression&gt;kermit&lt;/formalExpression&gt;
      &lt;/resourceAssignmentExpression&gt;
    &lt;/humanPerformer&gt;
  &lt;/userTask&gt;</programlisting>
				</para>
				
				<para>
				  <emphasis role="bold">Only one</emphasis> user can be assigned as human performer to the task.
				  In Activiti terminology, this user is called the <emphasis role="bold">assignee</emphasis>.
				  Task that have an assignee are not visible in the task lists of other people, and
				  are found in the so-called <emphasis role="bold">personal task list</emphasis> of the assignee. 
				</para>
				
				<para>
				  Tasks directly assigned to users can be retrieved through the TaskService as follows:
				  <programlisting>
List&lt;Task&gt; tasks = taskService.findAssignedTasks(&quot;kermit&quot;);</programlisting>
				  Or the TaskQuery API can be used:
				  <programlisting>
List&lt;Task&gt; tasks = taskService.createTaskQuery().assignee(&quot;kermit&quot;).list();</programlisting>
          
          Both code snippets will retrieve the tasks where the assignee currently is the given user.
				</para>

        <para>
          Tasks can also be put in the so-called <emphasis role="bold">candidate task list</emphasis>
          of people. In that case, the <emphasis role="bold">potentialOwner</emphasis> construct must be used.
          The usage is similar to the <emphasis>humanPerformer</emphasis> construct. Do note that it is 
          required to define for each element in the formal expression to specify if it is
          a user or a group (the engine cannot guess this).
          <programlisting>
&lt;process ...
  
  ...
  
  &lt;userTask id='theTask' name='important task' &gt;
    &lt;potentialOwner&gt;
      &lt;resourceAssignmentExpression&gt;
        <emphasis role="bold">&lt;formalExpression&gt;user(kermit), group(management)&lt;/formalExpression&gt;</emphasis>
      &lt;/resourceAssignmentExpression&gt;
    &lt;/potentialOwner&gt;
  &lt;/userTask&gt;</programlisting>
        </para>
        
        <para>
          Tasks defines with the <emphasis>potential owner</emphasis> construct, can be retrieved as follows
          (or a similar <emphasis>TaskQuery</emphasis> usage as for the tasks with an assignee):
          <programlisting>
 List&lt;Task&gt; tasks = taskService.findUnassignedTasks(&quot;kermit&quot;);</programlisting>
          
          This will retrieve all tasks where kermit is a <emphasis role="bold">candidate user</emphasis>,
          ie. the formal expression contains <emphasis>user(kermit)</emphasis>. This will also
          retrieve all tasks that are <emphasis role="bold">assigned to a group where kermit is
          a member of</emphasis> (eg <emphasis>group(management)</emphasis>, if kermit is a member of that group).
          Note that the groups of the user are resolved at runtime and these can be 
          managed through the <emphasis>IdentityService</emphasis>.
        </para>
        
        <para>
          If no specifics are given whether the given text string is a user or group, 
          the engine defaults to group. So the following would be the same as when
          <emphasis>group(accountancy) was declared</emphasis>.
          <programlisting>
&lt;formalExpression&gt;accountancy&lt;/formalExpression&gt;</programlisting>
        </para>
        
        <section id="bpmnUserTaskUserAssignmentExtension">
          
          <title>Custom extension for simple task assignments</title>
          
          <para>
            It is clear that user and group assigmnents are quite cumbersome
            for use cases where the assignment is not complex. 
            To avoid these complexities, <link linkend="bpmnCustomExtensions">custom extensions</link>
            on the user task are possible.
          </para>
          
          <para>
            <itemizedlist>
              <listitem>
                <para>
                  <emphasis role="bold">assignee attribute</emphasis>: this custom extension allows to
                  directly assign a user task to a given user.
                  <programlisting>
&lt;userTask id=&quot;theTask&quot; name=&quot;my task&quot; activiti:assignee=&quot;kermit&quot; /&gt;</programlisting>

                  This is exactly the same as using a <emphasis role="bold">humanPerformer</emphasis> 
                  construct as defined <link linkend="bpmnUserTaskAssignment">above</link>.
                </para>
              </listitem>
              <listitem>
                <para>
                  <emphasis role="bold">candidateUsers attribute</emphasis>: this custom extension allows to
                  make a user a candidate for a task.
                  <programlisting>
&lt;userTask id=&quot;theTask&quot; name=&quot;my task&quot; activiti:candidateUsers=&quot;kermit, gonzo&quot; /&gt;</programlisting>

                  This is exactly the same as using a <emphasis role="bold">potentialOwner</emphasis> 
                  construct as defined <link linkend="bpmnUserTaskAssignment">above</link>.
                  Note that it is not required to use the <emphasis>user(kermit)</emphasis> declaration
                  as is the case with the <emphasis>potential owner</emphasis> construct, since the attribute 
                  can only be used for users.
                </para>
              </listitem>
              <listitem>
                <para>
                  <emphasis role="bold">candidateGroups attribute</emphasis>: this custom extension allows to
                  make a group a candidate for a task.
                  <programlisting>
&lt;userTask id=&quot;theTask&quot; name=&quot;my task&quot; activiti:candidateGroups=&quot;management, accountancy&quot; /&gt;</programlisting>

                  This is exactly the same as using a <emphasis role="bold">potentialOwner</emphasis> 
                  construct as defined <link linkend="bpmnUserTaskAssignment">above</link>.
                  Note that it is not required to use the <emphasis>group(management)</emphasis> declaration
                  as is the case with the <emphasis>potential owner</emphasis> construct, since the attribute 
                  can only be used for groups.
                </para>
              </listitem>
              <listitem>
                <para>
                  <emphasis>candidateUsers</emphasis> and <emphasis>candidateGroups</emphasis> can both
                  be defined on the same user task.
                </para>
              </listitem>
            </itemizedlist>
          </para>
          
        </section> <!-- task assignment extensions -->

			</section> <!-- task assignment -->

		</section>
		
		<section id="bpmnScriptTask">
		
		  <title>Script Task</title>
		  
		  <section id="bpmnScriptTaskDescription">
		  
		    <title>Description</title>
		    
		    <para>
		      A script task is an automatic activity. When a process execution arrives at the 
		      script task, the corresponding script is executed. 
		    </para>
		  
		  </section>
		  
		  <section id="bpmnScriptTaskGraphicalNotation">
		  
		    <title>Graphical Notation</title>
		    
		    <para>
		      A script task is visualized as a typical BPMN 2.0 task (roundend rectangle),
		      with a small 'script' icon in the top-left corner of the rectangle.
		      <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.scripttask.png"/></imageobject></mediaobject>
		    </para>
		  
		  </section>
		  
		  <section id="bpmnScriptTaskXml">
		  
		    <title>XML representation</title>
		    
		    <para>
		      A script task is defined by specifying the <emphasis role="bold">script</emphasis>
		      and the <emphasis role="bold">scriptFormat</emphasis>.
<programlisting>
&lt;scriptTask id=&quot;theScriptTask&quot; name=&quot;Execute script&quot; scriptFormat=&quot;groovy&quot;&gt;
  &lt;script&gt;
    sum = 0
    for ( i in inputArray ) {
      sum += i
    }
  &lt;/script&gt;
&lt;/scriptTask&gt;</programlisting>
		    </para>
		    
		    <para>
		      The value of the <emphasis role="bold">scriptFormat</emphasis> attribute must be a
		      name that is compatible with the <ulink url="http://jcp.org/en/jsr/detail?id=223">JSR-223</ulink>
		      (scripting for the Java platform). The Groovy jar is shipped by default with the
		      Activiti distribution. If you want to use another (JSR-223 compatible) scripting
		      engine, it is sufficient to add the corresponding jar to the classpath and use
		      the appropiate name.
		    </para>
		    
		  </section>
		  
		  <section id="bpmnScriptTaskVariables">
		  
		    <title>Variables in scripts</title>
		    
		    <para>
		      All process variables that are accessible through the execution that arrives in the
		      script task, can be used within the script. In the example, the script variable
		      <emphasis>'inputArray'</emphasis> is in fact a process variable (an array of integers).
<programlisting>
&lt;script&gt;
    sum = 0
    for ( i in <emphasis role="bold">inputArray</emphasis> ) {
      sum += i
    }
&lt;/script&gt;</programlisting>
		    </para>
		    
		    <para>
		      It's also possible to set process variables in a script, simply by using an assignment
		      statement. In the example above, the <emphasis>'sum'</emphasis> variable will be
		      stored as a process variable after the script task has been executed. To avoid 
		      this behavior, script-local variables can be used. In Groovy, the keyword 
		      <emphasis>'def'</emphasis> must then be used: <emphasis>'def sum = 0'</emphasis>.
		      In that case, no process variable will be stored.
		    </para>
		    
		    <para>
		      An alternative is to set variables through the current execution, which is available
		      as a reserved variable called <emphasis>'execution'</emphasis>.
<programlisting>
&lt;script&gt;
    def scriptVar = &quot;test123&quot;
    execution.setVariable(&quot;myVar&quot;, scriptVar)
&lt;/script&gt;</programlisting>
		    </para>
		    
		    <para>
		      Note: the following names are reserved and <emphasis role="bold">cannot be used</emphasis> 
		      as variable names: <emphasis role="bold">out, out:print, lang:import, context, elcontext</emphasis>.
		    </para>
		  
		  </section>
		
		</section> 
		
		<section id="bpmnJavaServiceTask">
	
	   <title>Java Service Task</title>
	   
	   <section id="bpmnJavaServiceTaskDescription">
	   
	     <title>Description</title>
	     
	     <para>
	       A Java service task is used to invoke an external Java class.
	     </para>
	   
	   </section>	
	   
	   <section id="bpmnJavaServiceTaskGraphicalNotation">
     
       <title>Graphical Notation</title>
       
       <para>
        A service task is visualized as a rounded rectangle with a small cogs icon in the top-left corner.
        <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.java.service.task.png"/></imageobject></mediaobject>
       </para>
     
     </section> 
     
     <section id="bpmnJavaServiceTaskXML">
     
       <title>XML representation</title>
       
       <para>
         To call a Java pojo during process execution, the fully qualified classname 
         needs to be provided by the <emphasis role="bold">'activiti:java'</emphasis>
         attribute.
<programlisting>
&lt;serviceTask id=&quot;javaService&quot; 
             name=&quot;My Java Service Task&quot; 
             activiti:class=&quot;org.activiti.MyActivityBehavior&quot; /&gt;
</programlisting>
       </para>
       
     </section> 
     
     <section id="bpmnJavaServiceTaskImplementation">
     
      <title>Implementation</title>
      
      <para>
        To implement a class that can be called during process execution, this class needs to
        implement the <emphasis>org.activiti.pvm.ActivityBehavior</emphasis> interface.
      </para>
      
      <para>
        Let's create for example a Java class that can be used to change a process variable String
        to uppercase. This class needs to implement the <emphasis>ActivityBehavior</emphasis>
        interface, which requires us to implement the <emphasis>execute(ActivityExecution)</emphasis>
        method. It's this operation that will be called by the engine and which needs to contain
        the business logic. Process instance information such as process variables, executions, etc.
        can be accessed and manipulated through the 
        <ulink url="http://activiti.org/javadocs/org/activiti/pvm/ActivityExecution.html">ActivityExecution</ulink>
        interface (click on the link for a detailed Javadoc of its operations).
<programlisting>
public class ToUppercaseActivityBehavior extends BpmnActivityBehavior implements ActivityBehavior {
  
  public void execute(ActivityExecution execution) throws Exception {
    String var = (String) execution.getVariable(&quot;input&quot;);
    var = var.toUpperCase();
    execution.setVariable(&quot;input&quot;, var);
    
    performDefaultOutgoingBehavior(execution);
  }
  
}
</programlisting>
        Also note that here we're extending from the <emphasis>org.activiti.impl.bpmn.BpmnActivityBehavior</emphasis> class.
        This allows us to convience methods such as 
        <itemizedlist>
          <listitem>
            <para>
              <emphasis>performDefaultOutgoingBehavior</emphasis>,
              which will execute the default BPMN 2.0 outgoing behavior: all outgoing
              sequence flow are taken in parallel and conditions on the sequence flow are evaluated
              before the sequence flow is selected for leaving the current activity.  
            </para>
          </listitem>
          <listitem>
            <para>
              <emphasis>performIgnoreConditionsOutgoingBehavior</emphasis>, which
              takes all outgoing sequence flow in parallel, regardless of having a condition
              defined on it (eg. this is the behavior of the
              <link linkend="bpmnParallelGateway">parallel gateway</link>).
            </para>
          </listitem>          
        </itemizedlist>
        Note that this class can be used by inheritance (as it is used here) or by composition.
      </para>
     
     </section>
  		
		</section>
		
		<section id="bpmnManualTask">
		
		  <title>Manual Task</title>
		  
		  <section id="bpmnManualTaskDescription">
		  
		    <title>Description</title>
		    
		    <para>
		      A <emphasis>Manual Task</emphasis> defines a task that is external to the BPM engine.
		      It is used to model work that is done by somebody, which the engine
		      does not need to know of, nor is there a system of UI interface.
		      For the engine, a manual task is handled as a <emphasis role="bold">pass-though activity</emphasis>,
		      ,automatically continuing the process from the moment process execution arrives into it. 
		    </para>
		  
		  </section>
		  
		  <section id="bpmnManualTaskGraphicalNotation">
		  
		    <title>Graphical Notation</title>
		    
		    <para>
		      A manual task is visualized as a rounded rectangle, with a little 'hand' icon 
		      in the upper left corner
		      <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.manual.task.png"/></imageobject></mediaobject>
		    </para>
		  
		  </section>
		  
		  <section id="bpmnManualTaskXml">
		  
		    <title>XML representation</title>
		    
		    <para>
		      <programlisting>&lt;manualTask id=&quot;myManualTask&quot; name=&quot;Call client for more information&quot; /></programlisting>
		    </para>
		  
		  </section>
		
		</section>
		
		<section id="bpmnBoundaryEvent">
		  
		  <title>Boundary events</title>
		  
		  <para>
		    Boundary events are <emphasis>catching</emphasis> events that are attached to an activity
		    (a boundary event can never be throwing). This means that while the activity is
		    running, the event is <emphasis>listening</emphasis> for a certain type of trigger. 
		    When the event is <emphasis>catched</emphasis>, the activity is interrupted and the 
		    sequence flow going out of the event are followed.
		  </para>
		  
		  <para>
		    All boundary events are defined in the same way:
<programlisting>
&lt;boundaryEvent id=&quot;myBoundaryEvent&quot; attachedToRef=&quot;theActivity&quot;&gt;
      &lt;XXXEventDefinition/&gt;
&lt;/boundaryEvent&gt;</programlisting>
		  </para>
		  
		  <para>
		    A boundary event is defined with
		    <itemizedlist>
		      <listitem>
		        <para>
		          A unique identifier (process-wide)
		        </para>
		      </listitem>
		      <listitem>
		        <para>
		          A reference to the activity to which the event is attached through the
		          <emphasis role="bold">attachedToRef</emphasis> attribute.
		          Note that a boundary event is defined on the same level as the activities
		          to which they are attached
		          (ie. no inclusion of the boundary event inside the activity).
		        </para>
		      </listitem>
		      <listitem>
		        <para>
		          An XML subelement of the form <emphasis>XXXEventDefinition</emphasis> 
		          (eg. <emphasis>TimerEventDefinition</emphasis>, <emphasis>ErrorEventDefinition</emphasis>, etc.)
		          defining the type of the boundary event. See the specific boundary event types
		          for more details.
		        </para>
		      </listitem>
		    </itemizedlist>
		  </para>
		  
		</section> <!-- Boundary event -->
		  
		<section id="bpmnTimerBoundaryEvent">
      
      <title>Timer Boundary Event</title>
        
      <section id="timerBoundaryEventDescription">
        
        <title>Description</title>
          
        <para>
          A timer boundary event acts as a stopwatch and alarm clock. When an execution arrives
          in the activity where the boundary event is attached to, a timer is started.
          When the timer fires (eg. after a specified interval), the activity is interrupted
          and the sequence flow going out of the timer boundary event are followed.
        </para>
        
      </section>
        
      <section id="bpmnTimerBoundaryEventGraphicalNotation">
        
        <title>Graphical Notation</title>
          
        <para>
          A timer boundary event is visualized as a typical boundary event (ie. circle
          on the border), with the timer icon on the inside.
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.boundary.timer.event.png"/></imageobject></mediaobject>
        </para>
        
      </section>
      
      <section id="bpmnTimerBoundaryEventXml">
      
        <title>XML Representation</title>
        
        <para>
          A timer boundary event is defined as a <link linkend="bpmnBoundaryEvent">regular boundary event</link>.
          The specific type subelement is in this case a <emphasis role="bold">timerEventDefinition</emphasis>
          element.
<programlisting>
&lt;boundaryEvent id=&quot;escalationTimer&quot; cancelActivity=&quot;true&quot; attachedToRef=&quot;firstLineSupport&quot;&gt;
   <emphasis role="bold">&lt;timerEventDefinition&gt;
    &lt;timeDuration&gt;PT4H&lt;/timeDuration&gt;
  &lt;/timerEventDefinition&gt;</emphasis>
&lt;/boundaryEvent&gt;          
</programlisting>
        </para>
        
        <para>
          To specify how long the timer should run before it is fired, a <emphasis>timeDuration</emphasis>
          can be specified as subelement of <emphasis>timerEventDefinition</emphasis>. The format
          used is the <ulink url="http://en.wikipedia.org/wiki/ISO_8601#Durations">ISO 8601</ulink>
          format (as required by the BPMN 2.0 specification).
        </para>
        
        <para>
          <emphasis role="bold">Note:</emphasis> boundary timer events are only fired when 
          the job executor is enabled (ie. <emphasis>job.executor.auto.activate=off</emphasis>
          needs to be removed from the <emphasis>activiti.properties</emphasis>, since the job
          executor is otherwise enabled by default). 
        </para>
      
      </section>
		
		</section> 
		
		<section id="bpmnSubProcess">
		
		  <title>SubProcess</title>
		  
		  <section id="bpmnSubProcessDescription">
		  
		    <title>Description</title>
		    
		    <para>
		      A <emphasis>subprocess</emphasis> is an activity that contains other activities, gateways,
		      events, etc. which on itself form a process that is part of the bigger process. 
		      A <emphasis>subprocess</emphasis> is completely defined inside a parent process
		      (that's why it's often called an <emphasis>embedded</emphasis> subprocess).
		    </para>
		    
		    <para>
		      Subprocesses have two major use cases:
		      <itemizedlist>
		        <listitem>
		          <para>
		            Subprocesses allow <emphasis role="bold">hierarchical modeling</emphasis>.
		            Many modeling tools allow that subprocesses can be <emphasis>collapsed</emphasis>, 
		            hiding all the details of the subprocess and displaying a high-level end-to-end
		            overview of the business process.
		          </para>
		        </listitem>
		        <listitem>
		          <para>
		            A subprocess creates a new <emphasis role="bold">scope for events</emphasis>.
		            Events that are thrown during execution of the subprocess, can be catched by
		            <link linkend="bpmnBoundaryEvent">a boundary event</link> on the boundary 
		            of the subprocess, thus creating a scope for that event limited to the subprocess.
		          </para>
		        </listitem>
		      </itemizedlist>
		    </para>
		    
		    <para>
		      Using a subprocess does impose some constraints:
		      <itemizedlist>
		        <listitem>
		          <para>
		            A subprocess can only have <emphasis role="bold">one none start event</emphasis>, no other
		            start event types are allowed. A subprocess must <emphasis role="bold">
		            at least have one end event</emphasis>. Note that the BPMN 2.0 specification
		            allows to ommit the start and end events in a sbprocess, but the current
		            Activiti implementation does not support this.
		          </para>
		        </listitem>
		        <listitem>
		          <para>
		            <emphasis role="bold">Sequence flow can not cross subprocess boundaries.</emphasis>
		          </para>
		        </listitem>
		      </itemizedlist>
		    </para>
		  
		  </section>
		  
		  <section id="bpmnSubProcessGraphicalNotation">
      
        <title>Graphical Notation</title>
        
        <para>
          A subprocess is visualized as a typical activity, ie. a rounded rectangle.
          In case the subprocess is <emphasis>collapsed</emphasis>, only the name and a plus-sign are displayed,
          giving a high-level overview of the process:
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.collapsed.subprocess.png"/></imageobject></mediaobject>
        </para>
        
        <para>  
          In case the subprocess is <emphasis>expanded</emphasis>, the steps of the subprocess
          are displayed within the subprocess boundaries:
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.expanded.subprocess.png"/></imageobject></mediaobject>
        </para>
        
        <para>
          One of the main reasons to use a subprocess, is to define a scope for a certain event.
          The following process model shows this: both the <emphasis>investigate software/investigate hardware</emphasis>
          tasks need to be done in parallel, but both tasks need to be done within a certain time,
          before <emphasis>Level 2 support</emphasis> is consulted.
          Here, the scope of the timer (ie. which activities must be done in time) is constrained by the subprocess. 
          <mediaobject><imageobject><imagedata align="center" fileref="images/bpmn.subprocess.with.boundary.timer.png"/></imageobject></mediaobject>
        </para>
      
      </section>
      
      <section id="bpmnSubProcessXML">
      
        <title>XML representation</title>
        
        <para>
          A subprocess is defined by the <emphasis>subprocess</emphasis> element.
          All activities, gateways, events, etc. that are part of the subprocess, need
          to be enclosed within this element.
          <programlisting>
&lt;subProcess id=&quot;subProcess&quot;&gt;
    
  &lt;startEvent id=&quot;subProcessStart&quot; /&gt;
  
  ... other subprocess elements ...

  &lt;endEvent id=&quot;subProcessEnd&quot; /&gt;
    
 &lt;/subProcess&gt;          
          </programlisting> 
        </para>
      
      </section>
		
		</section>

	</section>

</chapter>
