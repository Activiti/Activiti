<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "../../../target/docbook-tool-1.0/docbook-xml/docbookx.dtd">

<chapter id="chapterApi">
  <title>The Activiti API</title>

  <section id="apiEngine">
    <title>Engine API</title>
    <para>The engine API is the most common way of interacting with
    Activiti. The central starting point is the <literal>ProcessEngine</literal>,
    which can be created in several ways as described in the 
    <link linkend="configuration">configuration section</link>.
    From the ProcessEngine, you can obtain the
    various services that contain the workflow/BPM
    methods.  ProcessEngine and the services objects are thread safe.
    So you can keep a reference to 1 of those for a whole server.
    </para>
    <mediaobject><imageobject><imagedata align="center" fileref="images/api.services.png"/></imageobject></mediaobject>
    <programlisting>ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();

RuntimeService runtimeService = processEngine.getRuntimeService();
RepositoryService repositoryService = processEngine.getRepositoryService();
TaskService taskService = processEngine.getTaskService();
ManagementService managementService = processEngine.getManagementService();
IdentityService identityService = processEngine.getIdentityService();
HistoryService historyService = processEngine.getHistoryService();
FormService formService = processEngine.getFormService();</programlisting>
    <para>The names of the service are quite self-explanatory.
    For detailed information on the services and the engine API, see<ulink url="../javadocs/index.html"> the javadocs</ulink>. 
    </para>
    
    <para><literal>ProcessEngines.getDefaultProcessEngine()</literal> will initialize and build a process 
    engine the first time it is called and afterwards always return the same process engine.  
    Proper creation and closing of all process engines can be done with <literal>ProcessEngines.init()</literal> 
    and <literal>ProcessEngines.destroy()</literal>
    </para>
    
    <para>The ProcessEngines class will scan for all <literal>activiti.cfg.xml</literal> and <literal>activiti-context.xml</literal> files.
    For all <literal>activiti.cfg.xml</literal> files, the process engine will be build in the typical Activiti way: <literal>ProcessEngineConfiguration.createProcessEngineConfigurationFromInputStream(inputStream).buildProcessEngine()</literal>.
    For all <literal>activiti-context.xml</literal> files, the process engine will be build in the Spring way: First
    the spring application context is created and then the process engine is obtained from that application context. 
    </para>

  </section>

  <section>
    <title>Exception strategy</title>
    <para>The base exception in Activiti is the <literal>org.activiti.engine.ActivitiException</literal>, an unchecked exception. This exception can be thrown at all times by the API, but 'expected' exceptions that 
    happen in specific methods are documented in the <ulink url="../javadocs/index.html"> the javadocs</ulink>.
    For example, an extract from <literal>TaskService</literal>:
    <programlisting>/**
 * Called when the task is successfully executed.
 * @param taskId the id of the task to complete, cannot be null.
 * @throws ActivitiException when no task exists with the given id.
 */
 void complete(String taskId);
    </programlisting>
    
    In the example above, when an id is passed for which no task exists, an exception will be thrown. Also, since the javadoc <emphasis role="bold">explicitly states that taskId cannot be null, an <literal>ActivitiException</literal> will be thrown when <literal>null</literal> is passed</emphasis>.
    </para>
    <para>
      Even though we want to avoid a big exception hierarchy, the following subclasses were added which are thrown in specific cases:
      <itemizedlist>
        <listitem>
            <para>
             <literal>ActivitiWrongDbException: </literal> Thrown when the Activiti engine discovers a mismatch between the database schema version and the engine version. 
            </para>
          </listitem>
          <listitem>
            <para>
             <literal>ActivitiOptimisticLockingException: </literal> Thrown when an optimistic locking occurs in the data store caused by concurrent access of the same data entry. 
            </para>
          </listitem>
          <listitem>
            <para>
             <literal>ActivitiClassLoadingException: </literal> Thrown when an class requested to load was not found or when error occurred while loading it (e.g. JavaDelegates, TaskListeners, ...).
            </para>
          </listitem>
      </itemizedlist>
    </para>
  </section>
  
  <section id="api.services">
    <title>Working with the Activiti services</title>
    <para>
        As described above, the way to interact with the Activiti engine is through the services exposed by 
        an instance of the <literal>org.activiti.engine.ProcessEngine</literal> class. The following 
        code snippets assume you have a working Activiti environment, ie. you have access
        to a valid <literal>org.activiti.engine.ProcessEngine</literal>. If you simply want to try
        out the code below, you can download or clone the 
        <ulink url="https://github.com/Activiti/activiti-unit-test-template">Activiti unit test template</ulink>,
        import it in your IDE and add a <literal>testUserguideCode()</literal> method to the 
        <literal>org.activiti.MyUnitTest</literal> unit test.  
    </para>
    <para>
        The end goal of this little tutorial will be to have a working business process which mimics
        a simplistic vacation request process at a company:
        <mediaobject><imageobject><imagedata align="center" fileref="images/api.vacationRequest.png"/></imageobject></mediaobject>
    </para>
    
    <section id="api.services.deployment">
        <title>Deploying the process</title>
        <para>
            Everything that is related to 'static' data (such as process definitions) are accessed
            through the <emphasis role="bold">RepositoryService</emphasis>. Conceptually, every such
            static piece of data is content of the 'repository' of the Activiti engine. 
        </para>
        <para>
            Create a new xml file <literal>VacationRequest.bpmn20.xml</literal> in the <literal>src/test/resources/org/activiti/test</literal>
            resource folder (or anywhere else if you're not using the unit test template) with the 
            following content. Note that this section won't explain the xml constructs being used in the example above. 
            Please read <link linkend="bpmn20">the bpmn 2.0 chapter to get yourself familiar</link>
            first if that hasn't happened yet.
            <programlisting>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;definitions id=&quot;definitions&quot;
             targetNamespace=&quot;http://activiti.org/bpmn20&quot; 
             xmlns=&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot;
             xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
             xmlns:activiti=&quot;http://activiti.org/bpmn&quot;&gt;
  
  &lt;process id=&quot;vacationRequest&quot; name=&quot;Vacation request&quot;&gt;
  
    &lt;startEvent id=&quot;request&quot; activiti:initiator=&quot;employeeName&quot;&gt;
      &lt;extensionElements&gt;
        &lt;activiti:formProperty id=&quot;numberOfDays&quot; name=&quot;Number of days&quot; type=&quot;long&quot; value=&quot;1&quot; required=&quot;true&quot;/&gt;
        &lt;activiti:formProperty id=&quot;startDate&quot; name=&quot;First day of holiday (dd-MM-yyy)&quot; datePattern=&quot;dd-MM-yyyy hh:mm&quot; type=&quot;date&quot; required=&quot;true&quot; /&gt;
        &lt;activiti:formProperty id=&quot;vacationMotivation&quot; name=&quot;Motivation&quot; type=&quot;string&quot; /&gt;
      &lt;/extensionElements&gt;
    &lt;/startEvent&gt;
    &lt;sequenceFlow id=&quot;flow1&quot; sourceRef=&quot;request&quot; targetRef=&quot;handleRequest&quot; /&gt;
    
    &lt;userTask id=&quot;handleRequest&quot; name=&quot;Handle vacation request&quot; &gt;
      &lt;documentation&gt;
        ${employeeName} would like to take ${numberOfDays} day(s) of vacation (Motivation: ${vacationMotivation}).
      &lt;/documentation&gt; 
      &lt;extensionElements&gt;
         &lt;activiti:formProperty id=&quot;vacationApproved&quot; name=&quot;Do you approve this vacation&quot; type=&quot;enum&quot; required=&quot;true&quot;&gt;
          &lt;activiti:value id=&quot;true&quot; name=&quot;Approve&quot; /&gt;
          &lt;activiti:value id=&quot;false&quot; name=&quot;Reject&quot; /&gt;
        &lt;/activiti:formProperty&gt;
        &lt;activiti:formProperty id=&quot;managerMotivation&quot; name=&quot;Motivation&quot; type=&quot;string&quot; /&gt;
      &lt;/extensionElements&gt;
      &lt;potentialOwner&gt;
        &lt;resourceAssignmentExpression&gt;
          &lt;formalExpression&gt;management&lt;/formalExpression&gt;
        &lt;/resourceAssignmentExpression&gt;
      &lt;/potentialOwner&gt;         
    &lt;/userTask&gt;
    &lt;sequenceFlow id=&quot;flow2&quot; sourceRef=&quot;handleRequest&quot; targetRef=&quot;requestApprovedDecision&quot; /&gt;
    
    &lt;exclusiveGateway id=&quot;requestApprovedDecision&quot; name=&quot;Request approved?&quot; /&gt;
    &lt;sequenceFlow id=&quot;flow3&quot; sourceRef=&quot;requestApprovedDecision&quot; targetRef=&quot;sendApprovalMail&quot;&gt;
      &lt;conditionExpression xsi:type=&quot;tFormalExpression&quot;&gt;${vacationApproved == 'true'}&lt;/conditionExpression&gt;
    &lt;/sequenceFlow&gt;
    
    &lt;task id=&quot;sendApprovalMail&quot; name=&quot;Send confirmation e-mail&quot; /&gt;
    &lt;sequenceFlow id=&quot;flow4&quot; sourceRef=&quot;sendApprovalMail&quot; targetRef=&quot;theEnd1&quot; /&gt;
    &lt;endEvent id=&quot;theEnd1&quot; /&gt;
    
    &lt;sequenceFlow id=&quot;flow5&quot; sourceRef=&quot;requestApprovedDecision&quot; targetRef=&quot;adjustVacationRequestTask&quot;&gt;
      &lt;conditionExpression xsi:type=&quot;tFormalExpression&quot;&gt;${vacationApproved == 'false'}&lt;/conditionExpression&gt;
    &lt;/sequenceFlow&gt;
    
    &lt;userTask id=&quot;adjustVacationRequestTask&quot; name=&quot;Adjust vacation request&quot;&gt;
      &lt;documentation&gt;
        Your manager has disapproved your vacation request for ${numberOfDays} days.
        Reason: ${managerMotivation}
      &lt;/documentation&gt;
      &lt;extensionElements&gt;
        &lt;activiti:formProperty id=&quot;numberOfDays&quot; name=&quot;Number of days&quot; value=&quot;${numberOfDays}&quot; type=&quot;long&quot; required=&quot;true&quot;/&gt;
        &lt;activiti:formProperty id=&quot;startDate&quot; name=&quot;First day of holiday (dd-MM-yyy)&quot; value=&quot;${startDate}&quot; datePattern=&quot;dd-MM-yyyy hh:mm&quot; type=&quot;date&quot; required=&quot;true&quot; /&gt;
        &lt;activiti:formProperty id=&quot;vacationMotivation&quot; name=&quot;Motivation&quot; value=&quot;${vacationMotivation}&quot; type=&quot;string&quot; /&gt;
        &lt;activiti:formProperty id=&quot;resendRequest&quot; name=&quot;Resend vacation request to manager?&quot; type=&quot;enum&quot; required=&quot;true&quot;&gt;
          &lt;activiti:value id=&quot;true&quot; name=&quot;Yes&quot; /&gt;
          &lt;activiti:value id=&quot;false&quot; name=&quot;No&quot; /&gt;
        &lt;/activiti:formProperty&gt;
      &lt;/extensionElements&gt;
      &lt;humanPerformer&gt;
        &lt;resourceAssignmentExpression&gt;
          &lt;formalExpression&gt;${employeeName}&lt;/formalExpression&gt;
        &lt;/resourceAssignmentExpression&gt;
      &lt;/humanPerformer&gt;  
    &lt;/userTask&gt;
    &lt;sequenceFlow id=&quot;flow6&quot; sourceRef=&quot;adjustVacationRequestTask&quot; targetRef=&quot;resendRequestDecision&quot; /&gt;
    
    &lt;exclusiveGateway id=&quot;resendRequestDecision&quot; name=&quot;Resend request?&quot; /&gt;
    &lt;sequenceFlow id=&quot;flow7&quot; sourceRef=&quot;resendRequestDecision&quot; targetRef=&quot;handleRequest&quot;&gt;
      &lt;conditionExpression xsi:type=&quot;tFormalExpression&quot;&gt;${resendRequest == 'true'}&lt;/conditionExpression&gt;
    &lt;/sequenceFlow&gt;
    
     &lt;sequenceFlow id=&quot;flow8&quot; sourceRef=&quot;resendRequestDecision&quot; targetRef=&quot;theEnd2&quot;&gt;
      &lt;conditionExpression xsi:type=&quot;tFormalExpression&quot;&gt;${resendRequest == 'false'}&lt;/conditionExpression&gt;
    &lt;/sequenceFlow&gt;
    &lt;endEvent id=&quot;theEnd2&quot; /&gt;
      
  &lt;/process&gt;
  
&lt;/definitions&gt;
            </programlisting>
        </para>
        
        <para>
            To make this process being known to the Activiti engine, we must 'deploy' it first.
            Deploying means that the engine will parse the BPMN 2.0 xml to something executable
            and a new database record will be added for each process definition included in the 
            'deployment'. This way, when the engine reboots, it will still know all of the 
            'deployed' processes:
            <programlisting>
ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();
RepositoryService repositoryService = processEngine.getRepositoryService();
repositoryService.createDeployment()
  .addClasspathResource(&quot;org/activiti/test/VacationRequest.bpmn20.xml&quot;)
  .deploy();
      
Log.info(&quot;Number of process definitions: &quot; + repositoryService.createProcessDefinitionQuery().count());            
            </programlisting>
        </para>    
       
        <para>
            Read more about deployment in the <link linkend="chDeployment">deployment chapter</link>.
        </para>    
    </section>
    
    <section id="api.services.start.processinstance">
        <title>Starting a process instance</title>
        <para>
            After deploying the process definition to the Activiti engine, we can start new process instances from it.
            For each process definition, there are typically many process instances. The process definition
            is the 'blueprint', while a process instance is a runtime execution of it. 
        </para>
        <para>
            Everything related to the runtime state of processes can be found in the <emphasis role="bold">RuntimeService</emphasis>.
            There are various way to start a new process instance. In the following snippet, we use the 
            key we defined in the process definition xml to start the process instance. We're also providing
            some process variables at process instance start, because the description of the first 
            user task will use these in its expressions. Process variables will be used all the time,
            as these variables give meaning to the process instance. Typically, the process variables
            are what make process instances differ.
            <programlisting>
Map&lt;String, Object&gt; variables = new HashMap&lt;String, Object&gt;();
variables.put(&quot;employeeName&quot;, &quot;Kermit&quot;);
variables.put(&quot;numberOfDays&quot;, new Integer(4));
variables.put(&quot;vacationMotivation&quot;, &quot;I'm really tired!&quot;);
      
RuntimeService runtimeService = processEngine.getRuntimeService();
ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(&quot;vacationRequest&quot;, variables);
      
// Verify that we started a new process instance
Log.info(&quot;Number of process instances: &quot; + runtimeService.createProcessInstanceQuery().count());           
            </programlisting>
        </para>
    </section>
    
    <section id="api.services.tasls">
        <title>Completing tasks</title>
        <para>
            When the process starts, the first step will be a user task. This is a step that must be performed
            by a user of the system. Typically, such a user will have an 'inbox of tasks' which lists
            all the tasks that need to be done by this user. Following code snippet shows how such a query might be performed:
            <programlisting>
// Fetch all tasks for the management group
TaskService taskService = processEngine.getTaskService();
List&lt;Task&gt; tasks = taskService.createTaskQuery().taskCandidateGroup(&quot;management&quot;).list();
for (Task task : tasks) {
  Log.info(&quot;Task available: &quot; + task.getName());
}            
            </programlisting>
        </para>
        <para>
            To continue the process instance, we need to finish this task. For the Activiti engine,
            this means you need to <literal>complete</literal> the task. Following snippet shows how this is done:
            <programlisting>
Task task = tasks.get(0);
      
Map&lt;String, Object&gt; taskVariables = new HashMap&lt;String, Object&gt;();
taskVariables.put(&quot;vacationApproved&quot;, &quot;false&quot;);
taskVariables.put(&quot;managerMotivation&quot;, &quot;We have a tight deadline!&quot;);
taskService.complete(task.getId(), taskVariables);            
            </programlisting>
            The process instance will now continue to the next step. In this example, this will
            be the first step again, because the task was not approved.
        </para>
    </section>
    
    <section id="api.services.suspend">
        <title>Suspending and activating a process</title>
        <para>
            It's possible to suspend a process definition. When a process definition is suspended,
            new process instance can't be created (an exception will be thrown). Suspending 
            the process definition is done through the <literal>RepositoryService</literal>:
            <programlisting>
repositoryService.suspendProcessDefinitionByKey(&quot;vacationRequest&quot;);
try {
  runtimeService.startProcessInstanceByKey(&quot;vacationRequest&quot;);
} catch (ActivitiException e) {
  e.printStackTrace();
}            
            </programlisting> 
            To reactivate a process definition, simply call one of the <literal>repositoryService.activateProcessDefinitionXXX</literal> methods.
        </para>
        <para>
            It's also possible to suspend a process instance. When suspended, the process cannot
            be continued (eg. completing a task throws an exception) and no jobs (such as timers)
            will executed. Suspending a process instance can be done by calling the 
            <literal>runtimeService.suspendProcessInstance</literal> method.
            Activating the process instance again, is done by calling the <literal>runtimeService.activateProcessInstanceXXX</literal> methods.
        </para>
    </section>
    
    <section id="api.services">
        <title>Further reading</title>
        <para>
            We've barely scratched the surface in the previous sections regarding Activiti functionality.
            We will expand these sections further in the future with additional coverage of the Activiti API.
            Of course, as with any open source project, the best way to learn is to inspect the code
            and read the Javadocs!
        </para>
    </section>
  
  </section>
  
  <section id="queryAPI">
    <title>Query API</title>
    <para>
      There are two ways of querying data from the engine: The query API and native queries. The Query API allows to 
      program with a fluent API completly typesafe queries. You can add various conditions to your queries, all of them
      are applied together (logical AND) and one ordering. The following code shows an example:
      <programlisting>
      List&lt;Task&gt; tasks = taskService.createTaskQuery()
         .taskAssignee("kermit")
         .processVariableValueEquals("orderId", "0815")
         .orderByDueDate().asc()
         .list();
      </programlisting>
      
      Sometimes you need more powerful queries, e.g. queries using an OR operator or restrictions you can not express by the Query API.
      Therefor we introduced native queries, where you can write your own SQL queries. The return type is defined by the Query object you use
      and the data will be mapped into the correct objects, e.g. Tasks. Since this will be fired against the database you have to 
      use table and column names as in the database, this requires some knowledge about the internal data structure and it is recommeded to use native
      queries with care. The table names can be retrieved via the API to keep the dependency as small as possible.
      
      <programlisting>
      List&lt;Task&gt; tasks = taskService.createNativeTaskQuery()
         .from(managementService.getTableName(Task.class) + " WHERE NAME_ = #{taskName}")
         .parameter("taskName", "gonzoTask").list();

      List&lt;Task&gt; tasks = taskService.createNativeTaskQuery()
         .from("ACT_RU_TASK")
         .list();

      List&lt;Task&gt; tasks = taskService.createNativeTaskQuery()
         .select("DISTINCT T1.*") // default is "*", but can be overwritten if you need it
         .from("ACT_RU_TASK T1, ACT_RU_TASK T2 WHERE T1.ID_ = T2.ID_") // okay, joining with ourselves doesn't make too much sense, agreed
         .list();
      
      List&lt;Task&gt; tasks = taskService.createNativeTaskQuery()
         .from(managementService.getTableName(Task.class) + " TASK, " + managementService.getTableName(VariableInstanceEntity.class) + " var WHERE VAR.TASK_ID_ = TASK.ID_")
         .list();
      </programlisting>
    </para>
  </section>
  
  <section id="apiExpressions">
    <title>Expressions</title>
    <para>Activiti uses UEL for expression-resolving. UEL stands for <emphasis>Unified Expression Language</emphasis> and is part of the EE6 specification (see
          <ulink url="http://docs.oracle.com/javaee/6/tutorial/doc/gjddd.html">
          the EE6 specification</ulink> for detailed information). To support all features of latest UEL spec on ALL environments, we use a modified version of JUEL.
    </para>
    <para>
      Expressions can be used in for example <link linkend="bpmnJavaServiceTaskXML">Java Service tasks</link>, <link linkend="executionListeners">Execution Listeners</link>, <link linkend="taskListeners">Task Listeners</link> and  <link linkend="conditionalSequenceFlowXml">Conditional sequence flows</link>.
      Although there are 2 types of expressions, value-expression and method-expression, Activiti makes abstraction of this and they can both be used where an <literal>expression</literal> is needed.
      <itemizedlist>
        <listitem>
          <para>
            <emphasis role="bold">Value expression</emphasis>: resolves to a value. By default, all process variables are available to use. Also all spring-beans (if using Spring) are available to use in expressions. 
            
            Some examples:
<programlisting>${myVar}
${myBean.myProperty}</programlisting>
          </para>
        </listitem>
        <listitem>
        <para>
            <emphasis role="bold">Method expression</emphasis>: invokes a method, with or without parameters. <emphasis role="bold">When invoking a method without parameters, be sure to add empty parentheses after the method-name.</emphasis>
            The passed parameters can be literal values or expressions that are resolved themselves. Examples:
<programlisting>${printer.print()}
${myBean.addNewOrder('orderName')}
${myBean.doSomething(myVar, execution)}
</programlisting>
          </para>
        </listitem>
      </itemizedlist>
      
      Note that these expressions support resolving primitives (incl. comparing them), beans, lists, arrays and maps.
    </para>
    <para>
      On top of all process-variables, there are a few object exposed that you can use in expressions:
      <itemizedlist>
        <listitem><para><literal>execution</literal>: The <literal>DelegateExecution</literal> that holds additional information about the ongoing execution.</para></listitem>
        <listitem><para><literal>task</literal>: The <literal>DelegateTask</literal> that holds additional information about the current Task.<emphasis role="bold">Note: Only works in expressions evaluated from task-listeners.</emphasis></para></listitem>
        <listitem><para><literal>authenticatedUserId</literal>: The id of the user that is currently authenticated. If no user is authenticated, variable is not available.</para></listitem>
      </itemizedlist>
    </para>
    <para>
      For more concrete usage and examples, check out <link linkend="springExpressions">Expressions in Spring</link>, <link linkend="bpmnJavaServiceTaskXML">Java Service tasks</link>, <link linkend="executionListeners">Execution Listeners</link>,  <link linkend="taskListeners">Task Listeners</link> or <link linkend="conditionalSequenceFlowXml">Conditional sequence flows</link>.
    </para>
    
  </section>

  <section id="apiUnitTesting">
    <title>Unit testing</title>
    <para>
      Business processes are an integral part of software projects and they should be tested
      in the same way normal application logic is tested: with unit tests. Since Activiti
      is an embeddable Java engine, writing unit test for business processes is as simple
      as writing regular unit tests.
    </para>
    <para>
      Activiti supports both JUnit versions 3 and 4 style of unit testing. In the JUnit 3 style,
      the <emphasis>org.activiti.engine.test.ActivitiTestCase</emphasis> must be extended.
      This will make the ProcessEngine and the services available through protected member fields. 
      In the <emphasis>setup()</emphasis> of the test,  the processEngine will be initialized
      by default with the <emphasis>activiti.cfg.xml</emphasis> resource on the classpath.  To specify a different
      configuration file, override the <emphasis>getConfigurationResource()</emphasis> method.
      Process engines are be cached statically over multiple unit tests when the configuration resource
      is the same. 
   </para>
   <para>
    By extending <emphasis>ActivitiTestCase</emphasis>, you can annotate test methods 
    with <emphasis>org.activiti.engine.test.Deployment</emphasis>. Before the test is run,
    a resource file of the form <emphasis>testClassName.testMethod.bpmn20.xml</emphasis>
    in the same package as the test class, will be deployed. At the end of the test, the deployment
    will be deleted, including all related process instances, tasks, etc. The <emphasis>Deployment</emphasis>
    annotation also supports setting the resource location explicitly. See 
    <ulink url="../javadocs/org/activiti/engine/test/Deployment.html">the Javadocs</ulink> for more
    details.
   </para> 
   <para>
     Taking all that in account, a JUnit 3 style test looks as follows.
     <programlisting>
public class MyBusinessProcessTest extends ActivitiTestCase {
   
  @Deployment
  public void testSimpleProcess() {
    runtimeService.startProcessInstanceByKey(&quot;simpleProcess&quot;);
    
    Task task = taskService.createTaskQuery().singleResult();
    assertEquals(&quot;My Task&quot;, task.getName());
    
    taskService.complete(task.getId());
    assertEquals(0, runtimeService.createProcessInstanceQuery().count());
  }
}      
      </programlisting>
    </para>
    <para>
      To get the same functionality when using the JUnit 4 style of writing unit tests, 
      the <emphasis>org.activiti.engine.test.ActivitiRule</emphasis> Rule must be 
      used. Through this rule, the process engine and services are available through getters. As with the 
      <emphasis>ActivitiTestCase</emphasis> (see above), including this Rule will enable the use
      of the <emphasis>org.activiti.engine.test.Deployment</emphasis> annotation (see above for an explanation
      of its use and configuration) and it will look for the default configuration file on the classpath. 
      Process engines are statically cached over multiple unit tests when using the same configuration resource. 
   </para>
   <para>
     Following code snippet shows an example of using the JUnit 4 style of testing and the 
     usage of the <emphasis>ActivitiRule</emphasis>. 
     <programlisting>
public class MyBusinessProcessTest {
  
  @Rule
  public ActivitiRule activitiRule = new ActivitiRule();
  
  @Test
  @Deployment
  public void ruleUsageExample() {
    RuntimeService runtimeService = activitiRule.getRuntimeService();
    runtimeService.startProcessInstanceByKey(&quot;ruleUsage&quot;);
    
    TaskService taskService = activitiRule.getTaskService();
    Task task = taskService.createTaskQuery().singleResult();
    assertEquals(&quot;My Task&quot;, task.getName());
    
    taskService.complete(task.getId());
    assertEquals(0, runtimeService.createProcessInstanceQuery().count());
  }
}
      </programlisting>
    </para>    
  </section>
  
  <section id="apiDebuggingUnitTest">
    <title>Debugging unit tests</title>
    
    <para>
      When using the in-memory H2 database for unit tests, following instructions allow to
      easily inspect the data in the Activiti database during a debugging session. The 
      screenshots here are taken in Eclipse, but the mechanism should be the similar for other 
      IDEs. 
    </para>
    
    <para>
      Suppose we have put a <emphasis>breakpoint</emphasis> somewhere in our unit test.
      In Eclipse this is done by double-clicking in the left border next to the code:
      <mediaobject><imageobject><imagedata align="center" fileref="images/api.test.debug.breakpoint.png"/></imageobject></mediaobject>
      If we now run the unit test in <emphasis>debug</emphasis> mode (right-click in test class,
      select 'Run as' and then 'JUnit test'), the test execution halts at our breakpoint, where
      we can now inspect the variables of our test as shown in the right upper panel.
      <mediaobject><imageobject><imagedata align="center" fileref="images/api.test.debug.view.png"/></imageobject></mediaobject>
      To inspect the Activiti data, open up the <emphasis>'Display'</emphasis> window 
      (if this window isn't there, open Window->Show View->Other and select <emphasis>Display</emphasis>). 
      and type (code completion is available) <literal>org.h2.tools.Server.createWebServer("-web").start()</literal>
      <mediaobject><imageobject><imagedata align="center" fileref="images/api.test.debug.start.h2.server.png"/></imageobject></mediaobject>
      Select the line you've just typed and right-click on it. Now select 'Display' (or execute the shortcut instead of right-clicking)
      <mediaobject><imageobject><imagedata align="center" fileref="images/api.test.debug.start.h2.server.2.png"/></imageobject></mediaobject>
      Now open up a browser and go to <ulink url="http://localhost:8082">http://localhost:8082</ulink>,
      and fill in the JDBC URL to the in-memory database (by default this is <literal>jdbc:h2:mem:activiti</literal>),
      and hit the connect button.
      <mediaobject><imageobject><imagedata align="center" fileref="images/api.test.debug.h2.login.png"/></imageobject></mediaobject>
      You can now see the Activiti data and use it to understand how and why your unit test is executing your
      process in a certain way.
      <mediaobject><imageobject><imagedata align="center" fileref="images/api.test.debug.h2.tables.png"/></imageobject></mediaobject>
    </para>
  
  </section>

  <section id="apiProcessEngineInWebApp">
    <title>The process engine in a web application</title>
    
    <para>
      The <literal>ProcessEngine</literal> is a thread-safe class and can
      easily be shared among multiple threads. In a web application, this 
      means it is possible to create the process engine when the container boots
      and shut down the engine when the container goes down.
    </para>
    
    <para>
      The following code snippet how you can write a simple ServletContextListener
      to initialize and destroy process engines in a plain Servlet environment:
      <programlisting>
public class ProcessEnginesServletContextListener implements ServletContextListener {
  
  public void contextInitialized(ServletContextEvent servletContextEvent) {
    ProcessEngines.init();
  }

  public void contextDestroyed(ServletContextEvent servletContextEvent) {
    ProcessEngines.destroy();
  }

}</programlisting>
      The contextInitialized will delegate to <literal>ProcessEngines.init()</literal>. That will
      look for <literal>activiti.cfg.xml</literal> resource files on the classpath,
      and create a <literal>ProcessEngines</literal> for the given configurations (e.g. multiple jars with a configuration file).
      If you have multiple such resource files on the classpath, make sure they all have different names.
      When the process engine  is needed, it can be fetched using <programlisting>ProcessEngines.getDefaultProcessEngine()</programlisting>
      or <programlisting>ProcessEngines.getProcessEngine("myName");</programlisting>
      Of course, it is also possible to use any of the variants of creating a process engine, 
      as described in the <link linkend="configuration">configuration section</link>.
    </para>
    
    <para>The contextDestroyed of the context-listener delegates to <literal>ProcessEngines.destroy()</literal>.
    That will properly close all initialized process engines.
    </para>
  </section>

</chapter>
